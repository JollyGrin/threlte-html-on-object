Directory structure:
└── learn/
    ├── advanced/
    │   ├── custom-abstractions.mdx
    │   ├── migration-guides.mdx
    │   ├── plugins.mdx
    │   └── webgpu.mdx
    ├── basics/
    │   ├── app-structure.mdx
    │   ├── disposing-objects.mdx
    │   ├── handling-events.mdx
    │   ├── loading-assets.mdx
    │   ├── render-modes.mdx
    │   └── scheduling-tasks.mdx
    ├── getting-started/
    │   ├── installation.mdx
    │   ├── introduction.mdx
    │   └── your-first-scene.mdx
    └── more/
        └── resources.mdx

================================================
File: apps/docs/src/content/learn/advanced/custom-abstractions.mdx
================================================
---
category: Advanced
title: Custom Abstractions
order: 1
---

A lot of the components you will find in the package
[@threlte/extras](/docs/reference/extras/getting-started) are abstractions on
top of the [`<T>` component](/docs/reference/core/t). These abstractions provide
extra functionality like automatically invalidating the frame or providing
default values or extra props.

A common use case for custom abstractions is to create a component that is a
fixed entity in your Threlte app which you want to reuse in multiple places or
which exposes a specific behavior. As an example, let's create a component that
is made up from multiple `<T>` components resembling a tile of some kind:

```svelte title="Tile.svelte"
<script>
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'

  let { children } = $props()
</script>

<T.Group>
  <!-- 2x2 Tile -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children()}
</T.Group>
```

Let's see what implementing that component looks like:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile />
```

## Props

The `<Tile>` component is now available in the scene and can be reused as many
times as you want.

Now we'd like to assign a different `position` to every `<Tile>` in order to
position it in the scene. We can do that by passing a `position` prop to the
`<Tile>` component:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile position={[0, 0, 0]} />
<Tile position={[2, 0, 0]} />
<Tile position={[4, 0, 0]} />
```

That doesn't work _yet_. The component `<Tile>` internally needs to make use of
the `position` prop to set the position of its children. We can do that by
[spreading `props` on the `<T.Group>`](https://svelte.dev/tutorial/spread-props)
component at the root hierarchy of `<Tile>`:

```svelte title="Tile.svelte" {5}m
<script>
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'

  let { children, ...props } = $props()
</script>

<T.Group {...props}>
  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children()}
</T.Group>
```

## Types

<Tip type="info">The following section assumes you use TypeScript.</Tip>

The last thing we need to do is to add types to our custom abstraction so that
IDEs like VS Code can provide autocompletion and type checking. We will create a
`types.ts` file next to the `Tile.svelte` file and add the following content:

```ts title="types.ts"
import type { Props } from '@threlte/core'
import type { Group } from 'three'

export type TileProps = Props<Group>
```

<Tip type="tip">
  As of now it's necessary to declare the props in a separate file.
	If you declare them inside the `<script>` block, the Svelte compiler
	flattens the resulting type, removing JSDoc comments and possibly
	breaking it.
</Tip>

The generic type `Props<Type>` is a utility type that extracts all possible
props that a `<T>` component accepts – in this case `<T.Group>`. It also creates
a _bindable `ref` prop_ that can be used to bind to the group created by the
`<T.Group>` component.

We need to import the `TileProps` type in our `Tile.svelte` file and make use of
the `ref` prop. For that we:

- Add the `lang="ts"` attribute to the `<script>` block
- Import the `TileProps` type
- Add the bindable prop `ref` to the props
- Bind `ref` to the bindable prop `ref` of the root `<T.Group>` component
- Pass `ref` to the `children()` block

```svelte title="Tile.svelte" {4,11}+ {1,6,19}m
<script lang="ts">
  import { T } from '@threlte/threlte'
  import { MathUtils } from 'three'
  import type { TileProps } from './types'

  let { children, ref = $bindable(), ...props }: TileProps = $props()
</script>

<T.Group
  {...props}
  bind:ref
>
  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * MathUtils.DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  {@render children({ ref })}
</T.Group>
```

Now we can use the `<Tile>` component in our scene and get autocompletion and
type checking.

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
  import { TransformControls } from '@threlte/extras'
</script>

<Tile position={[2, 0, 2]}>
  {#snippet children({ ref })}
    <TransformControls object={ref} />
  {/snippet}
</Tile>
```


================================================
File: apps/docs/src/content/learn/advanced/migration-guides.mdx
================================================
---
category: More
title: Migration Guides
order: 2
---

## Threlte 8

Threlte 8 adds Svelte 5 support and removes Svelte 4 support.

This upgrade contains bug fixes, better average performance, smaller bundle size, and an improved development experience.

There are a few notable breaking changes listed below.

### Automatic Disposal

[Automatic disposal](/docs/learn/basics/disposing-objects) has been improved to
only dispose of objects that are referenced by a `<T>` component. Objects are no
longer scanned recursively for disposable objects.

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const map = useTexture('/some/texture.png')
</script>

{#if $map}
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshBasicMaterial map={$map} />
  </T.Mesh>
{/if}
```

In this example, Threlte 7 also disposed of the texture when the material
unmounted. This is no longer the case in Threlte 8. This change is introduced to
improve performance and to make the behavior of automatic disposal more
intuitive. When looking at simple examples like the one above, this might seem
like a regression, but with scale the previous approach of deeply recursive
automatic disposal was hard to reason about and a performance bottleneck.

### Plugin API

The plugin API has been changed to allow for greater granularity and a reactivity model that is in-line with Svelte 5.

#### `createPlugin` has been removed

Threlte 7 included a function called `createPlugin` that allowed to separate a
plugin declaration from its implementation. The recommended way to create
plugins is to export a function that invokes `injectPlugin`:

```ts
import { injectPlugin } from '@threlte/core'

export const createSomePlugin = (pluginArg: string) => {
  injectPlugin('some-plugin', () => {
    // ... Plugin Code
  })
}
```

This plugin can now be implemented like this:

```svelte title="Scene.svelte"
<script>
  import { createSomePlugin } from '$plugins'

  createSomePlugin('plugin-arg')
</script>
```

#### Plugin callbacks have been removed

In Threlte 7, plugins could return an object with several callback functions
that were invoked when:

- `ref` changed
- any prop changed (e.g. `makeDefault`, `dispose`, `attach`, etc.)
- any "rest" prop changed (e.g. `position`, `color`, etc.)

```ts title="Threlte 7"
injectPlugin('some-plugin', ({ ref, props }) => {
  return {
    onRefChange(newRef) {
      // ...
    },
    onPropsChange(props) {
      // ...
    },
    onRestPropsChange(restProps) {
      // ...
    }
  }
})
```

These callbacks have been removed. Instead, you can use the first argument of the plugin
callback, which is a reactive object containing all properties needed:

```ts title="Threlte 8"
injectPlugin('some-plugin', (args) => {
  args.ref
  args.makeDefault
  args.args
  args.attach
  args.manual
  args.makeDefault
  args.dispose
  args.props // All other props declared on the component
})
```

The `args` object is reactive and will update whenever any of the referenced values change.

<Tip type="info">
  A plugin may still return an object with `pluginProps` to specify which props
	the `<T>` component should not react to.
</Tip>

### Events

Events will no longer work, and have been replaced with callback props.

```svelte {2,3}m
<T.Mesh
  onclick={onClick}
  onpointerenter={onPointerEnter}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

The signature of the `oncreate` callback prop has changed. Instead of receiving an object with a cleanup function,
you may now return a cleanup function that will run when the object is destroyed or its args change. This is more in-line with other apis in svelte 5 and threlte.

```svelte
<T.Mesh
  oncreate={(ref) => {
    return () => {
      console.log('cleanup')
    }
  }}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

The `createRawEventDispatcher` and `forwardEventHandlers` exports will no longer work.

Instead of dispatching events with `createRawEventDispatcher`, invoke callback props.

```svelte
<script lang="ts">
  import { T } from '@threlte/core'
  import { OrbitControls } from '@threlte/extras'

  type Props = {
    onchange?: () => void
  }

  let { onchange }: Props = $props()

  onchange?.()
</script>

<T.PerspectiveCamera makeDefault>
  <OrbitControls {onchange} />
</T.PerspectiveCamera>
```

Instead of using `forwardEventHandlers`, pass rest props
to the component you wish to forward events to.

```svelte
<script>
  let { ...rest } = $props()
</script>

<T.Mesh {...rest}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

This will pass the new callback props mentioned in the previous section down the tree of components.

### Attach API & Trait Components

The signature and heuristic of the attach API of the `<T>` component has
changed. The trait components `<HierarchicalObject>` and `<SceneGraphObject>`
have been removed.

#### `attach` Function Signature

```svelte
<!-- Threlte 7 -->
<T.Mesh
  attach={(parent, self) => {
    console.log('attaching', parent, self)
    return () => {
      console.log('detaching', parent, self)
    }
  }}
/>

<!-- Threlte 8 -->
<T.Mesh
  attach={({ ref, parent, parentObject3D }) => {
    console.log('attaching', ref, parent, parentObject3D)
    return () => {
      console.log('detaching', ref, parent, parentObject3D)
    }
  }}
/>
```

#### `attach={false}`

If `false` is passed to the `attach` prop, the component will not be automatically attached to
the parent object. This is useful if you want to attach the component manually.

```svelte
<!-- "Dangling" component -->
<T
  is={mesh}
  attach={false}
/>
```

#### `attach={object3D}`

If an object3D instance is passed to the `attach` prop, the component will be attached to the instance, essentially acting as a portal.

<Tip type="warning">Be aware that the component still acts in the given context of the parent.</Tip>

```svelte
<!-- Attached to the provided object -->
<T
  is={mesh}
  attach={object3D}
/>
```

### Snippets

Slot props will no longer work, and must be replaced with snippets.
For example, the following components from Threlte 7 would need to be migrated from this:

```svelte
<T.PerspectiveCamera let:ref>
  <T.OrbitControls
    args={[ref, renderer.domElement]}
    on:change={invalidate}
  />
</T.PerspectiveCamera>
```

...to this:

```svelte
<T.PerspectiveCamera>
  {#snippet children({ ref })}
    <T.OrbitControls
      args={[ref, renderer.domElement]}
      onchange={invalidate}
    />
  {/snippet}
</T.PerspectiveCamera>
```

Any component that previously exposed a slot prop using the `let:` directive can follow this new pattern.

### Canvas component `size` prop

The `size` property on the `<Canvas>` component that allowed setting specific pixel dimensions has been removed.
To set a specific size of your `<Canvas>`, simply wrap it in an HTML element with your desired dimensions.

```svelte
<div style="width: 500px; height: 300px;">
  <Canvas>
    <Scene />
  </Canvas>
</div>
```

### Canvas component `rendererParameters` prop

The `renderParameters` canvas prop has been replaced with a more powerful `createRenderer` function.

If you need to manually set renderer parameters, call the function and return a renderer.

```svelte
<Canvas
  createRenderer={(canvas) => {
    return new WebGLRenderer({
      canvas,
      alpha: true,
      powerPreference: 'high-performance',
      antialias: false,
      depth: false,
      premultipliedAlpha: false
    })
  }}
>
  <Scene />
</Canvas>
```

Any Three renderer can be returned when calling `createRenderer`.

### Transitions

The transitions plugin currently does not work, we're working towards a new
transition system.

### `useGltf` and `<GLTF>`

`useGltf` and `<GLTF>` no longer contain a built-in `DracoLoader`, `KTX2Loader`, or `MeshoptDecoder`.
Instead, separate hooks can be imported and passed to these tools, improving their bundle size and flexibility.

```ts
import { useGltf, useDraco, useKtx2, useMeshopt } from '@threlte/extras'

const dracoLoader = useDraco()
const ktx2Loader = useKtx2()
const meshoptDecoder = useMeshopt()

const gltf = useGltf('./path/to/model.glb', {
  dracoLoader,
  ktx2Loader,
  meshoptDecoder
})
```

For more information, see the [`useGltf`](/docs/reference/extras/use-gltf) and [`GLTF`](/docs/reference/extras/gltf) docs.

### Rapier

#### Two Stage Physics

In order to enable fixed frame physics, the Rapier package is introducing two
[scheduler stages](/docs/learn/basics/scheduling-tasks#stages). So in the most
simple physics implementation:

```svelte
<Canvas>
  <World>
    <Scene />
  </World>
</Canvas>
```

The scheduler plan will look like this:

```txt
scheduler
├─ threlte-main-stage
├─ simulation
│  └─ simulation
├─ synchronization
│  └─ synchronization
└─ threlte-render-stage
```

[Tasks](/docs/learn/basics/scheduling-tasks#tasks) that are added to the
`simulation` stage will be executed according to the set
[framerate](/docs/reference/rapier/framerate), i.e. the delta provided in these
tasks corresponds to the delta time between physics frames. Tasks added to the
`synchronization` stage will be executed after all tasks of the `simulation`
stage have been executed, the delta is the regular `requestAnimationFrame` frame
delta. The stages and tasks are available as part of the `RapierContext` with the `useRapier` hook:

```ts
import { useTask } from '@threlte/core'
import { useRapier } from '@threlte/rapier'

const { simulationTask } = useRapier()

useTask(
  () => {
    // E.g. interact with the physics world here
  },
  {
    before: simulationStage
  }
)
```

#### BasicPlayerController has been removed

The `BasicPlayerController` component has been removed. If you need a player
controller, Rapier comes with a pre-made, easy to implement [Character
Controller](https://rapier.rs/docs/user_guides/javascript/character_controller).
It's more powerful and flexible than the old component.

The reason is stated in rapier's documentation as well:

> Despite the fact that this built-in character controller is designed to be
> generic enough to serve as a good starting point for many common use-cases,
> character-control (especially for the player's character itself) is often very
> game-specific. Therefore the builtin character controller may not work
> perfectly out-of-the-box for all game types.

#### `oncreate` event signature

The `oncreate` event signature available on `<RigidBody>`, `Collider` and
`<AutoColliders>` has been adapted to match the `oncreate` prop on `<T>`.

```svelte
<RigidBody
  oncreate={(ref) => {
    // ref is the created RigidBody instance
    return () => {
      // cleanup function
    }
  }}
>
  <!-- ... -->
</RigidBody>
```

## Threlte 7

Threlte 7 introduces a new _Task Scheduling System_ that allows you to easily
orchestrate the task execution order of your Threlte application. For details on
how to use it, see the [documentation](/docs/learn/basics/scheduling-tasks).
Before, you had the option to choose between `useFrame` and `useRender` to
orchestrate your rendering pipeline. These hooks are currently still available
but will be removed in the next major version of Threlte. This guide will help
you migrate your application to the new Task Scheduling System.

This update also slightly changes the signature of the `<Canvas>` component as
well as the Threlte context.

Also, to increase performance we're enforcing the use of constant prop types
on the `<T>` component.

### Constant prop types on `<T>`

The `<T>` component now enforces the use of _constant prop types_. This means
that the type of a certain prop value must not change in the lifetime of a
component. See this example:

```svelte title="Threlte 6"
<script>
  import { T } from '@threlte/core'

  let position = [0, 0, 0]

  const changePosition = () => {
    position = 1
  }
</script>

<T.Mesh {position} />
```

When `changePosition` is invoked, the prop type of the prop `position` changes
from an array of numbers to a number. This is not allowed anymore in Threlte 7.
Prop types must be constant. It's a highly unlikely scenario that rarely occurs
and a rather bad practice to start with, which allows us to optimize the
performance of the `<T>` component by enforcing this rule. This is how you would
migrate the above example:

```svelte title="Threlte 7" {7}m
<script>
  import { T } from '@threlte/core'

  let position = [0, 0, 0]

  const changePosition = () => {
    position = [1, 1, 1]
  }
</script>

<T.Mesh {position} />
```

### Threlte context

### `<Canvas>` props

#### `frameloop`

`frameloop` is now called `renderMode` as it only affects the rendering of your
Threlte application. It accepts nearly the same values as before:

```ts title="Threlte 6"
<Canvas frameloop="always" />
<Canvas frameloop="demand" />
<Canvas frameloop="never" />
```

```ts title="Threlte 7"
<Canvas renderMode="always" />
<Canvas renderMode="on-demand" />
<Canvas renderMode="manual" />
```

If the value is `always`, Threlte will render your scene on every frame. If the
value is `on-demand`, Threlte will only render your scene when a re-render is
needed. If the value is `manual`, Threlte will never render your scene
automatically and you have to trigger a re-render by calling `advance()` on the
Threlte context available via `useThrelte()`.

#### `autoRender`

When `autoRender` is `false`, Threlte will not render your scene automatically
and will enable you to implement a custom render pipeline using the hook
[`useTask`](/docs/reference/core/use-task). If adding a task to render the scene
to Threlte's
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages), the task
will only be called in respect to the `renderMode` prop. Previously, this
behavior was inferred from the usage of the `useRender` hook, but we think being
explicit here is better.

### `useFrame`

The hook [`useTask`](/docs/reference/core/use-task) replaces `useFrame`. It has
a slightly different signature and allows you to to add a `task` to Threlte's
_Task Scheduling System_. A task may have dependencies to other tasks, which you
can think of as the big brother of the `order` option of `useFrame`.

#### Callback Arguments

The callback to `useTask` now only receives the delta time since the last frame.
The Threlte context previously available as the first argument to the callback
of `useFrame` should be retrieved using the hook
[`useThrelte`](/docs/reference/core/use-threlte).

```ts title="Threlte 6"
useFrame(({ camera, scene }, delta) => {
  // The Threlte context was previously available as the first
  // argument to the callback, followed by the delta time since the
  // last frame.
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // The delta time since the last frame is the only
  // argument to the callback.
})
```

#### `autostart` and `invalidate`

The options of `useTask` have been renamed to better reflect their purpose. The
`autostart` option is now called `autoStart` (note the **capital 'S'**),
`invalidate` is now called `autoInvalidate`.

#### If you didn't use the `order` option

Replace `useFrame` with `useTask` and adapt accessing the Threlte context.

```ts title="Threlte 6"
useFrame(({ camera, scene }, delta) => {
  // ...
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // ...
})
```

#### If you used the `order` option

Migrate to `useTask` by referencing the key of the task you want to depend on.

```ts title="Threlte 6"
useFrame(
  (_, delta) => {
    // This task will be executed first
  },
  { order: 0 }
)

useFrame(
  (_, delta) => {
    // This task will be executed second
  },
  { order: 1 }
)
```

```ts title="Threlte 7"
useTask('first', (delta) => {
  // ...
})

useTask(
  'second',
  (delta) => {
    // This task will be executed after the task with the
    // key 'first' has been executed.
  },
  { after: 'first' }
)
```

### `useRender`

The hook [`useTask`](/docs/reference/core/use-task) also replaces `useRender`.
Previously, `useRender` allowed you to define a callback that was invoked after
all `useFrame` callbacks have been invoked to render your scene with a custom
render pipeline. This is now possible with `useTask` as well. Threlte provides a
[`renderStage`](/docs/learn/basics/scheduling-tasks#default-stages) that only
ever executes its tasks when a re-render is needed. A task added to this stage
can be used to render your scene. Be sure to set the option `autoInvalidate` to
`false` to prevent Threlte from automatically invalidating the render stage.

```ts title="Threlte 6"
useRender(() => {
  // Render your scene here
})
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()
useTask(
  'render',
  () => {
    // Render your scene here
  },
  { stage: renderStage, autoInvalidate: false }
)
```

#### Callback Arguments

The callback to `useTask` now only receives the delta time since the last frame.
The Threlte context previously available as the first argument to the callback
of `useRender` should be retrieved using the hook
[`useThrelte`](/docs/reference/core/use-threlte).

```ts title="Threlte 6"
useRender(({ camera, scene }, delta) => {
  // The Threlte context was previously available as the first
  // argument to the callback, followed by the delta time since the
  // last frame.
})
```

```ts title="Threlte 7"
const { camera, scene } = useThrelte()
useTask((delta) => {
  // The delta time since the last frame is the only
  // argument to the callback.
})
```

#### If you didn't use the `order` option

Replace `useFrame` with `useTask` and adapt accessing the Threlte context.

```ts title="Threlte 6"
useRender((_{ camera, scene }_, delta) => {
  // ...
})
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()
useTask(
  (delta) => {
    // ...
  },
  { stage: renderStage, autoInvalidate: false }
)
```

#### If you used the `order` option

Migrate to `useTask` by referencing the key of the task you want to depend on.

```ts title="Threlte 6"
useRender(
  (_, delta) => {
    // This task will be executed first
  },
  { order: 0 }
)

useRender(
  (_, delta) => {
    // This task will be executed second
  },
  { order: 1 }
)
```

```ts title="Threlte 7"
const { renderStage } = useThrelte()

useTask(
  'first',
  (delta) => {
    // ...
  },
  { stage: renderStage, autoInvalidate: false }
)

useTask(
  'second',
  (delta) => {
    // This task will be executed after the task with the
    // key 'first' has been executed.
  },
  { after: 'first', stage: renderStage, autoInvalidate: false }
)
```

## Migrating from Threlte 5 to Threlte 6

Threlte 6 provides a much more mature and feature-rich API and developer experience than
its predecessor at the cost of a lot of breaking changes. This guide will help you migrate
your Threlte 5 project to Threlte v6.

### Preprocessing

Preprocessing is not needed anymore starting from Threlte 6. This means you
may remove the preprocessor `@threlte/preprocess` from your project as well as its
configuration in `svelte.config.js`. You can now use the [component `<T>`](/docs/reference/core/t) directly.

### `<Three>` is now `<T>`

Threlte 6 merges the `<Three>` and `<T>` components into a single component. The property `type` was renamed to `is`
to also properly reflect the fact that it can be used with already instantiated objects.

### `@threlte/core` is only about the `<T>` component

The `@threlte/core` package is now only about the `<T>` component. It does not provide any abstractions
that have been part of the core package before. _Some_ of these abstractions (`<TransformControls>`,
`<OrbitControls>`, audio components and several hooks) have been moved to `@threlte/extras` as this is the new
home for commonly used abstractions.

### Prop types

Threlte 6 heavily relies on prop types that Three.js naturally understands. As such, the prop types you may have
previously used to define for example the position of an object changed. Threlte v5 provided its own prop types
`Position` (e.g. `{ x, y, z }`), `Rotation` and others which are now removed or deprecated. While not yet all
abstractions fully make use of the new prop types, we're working on it. Your editor should be able to provide
you with the correct prop types for the components you're using.

### Interactivity

Interactivity is now handled by a plugin that's available at `@threlte/extras`. It's much more mature and flexible
in terms of event handling. For instance – as some of you requested – you may now define on what object the main
event listener is placed. Check out [its documentation](/docs/reference/extras/interactivity) to learn more.

### `useLoader` now returns a store

The hook [`useLoader`](/docs/reference/core/hooks#useloader) now returns a custom Svelte store called
[`AsyncWritable`](/docs/reference/core/utilities#asyncwritable). This store allows you to [await](https://svelte.dev/tutorial/await-blocks)
the loading of the resource while also implementing a regular Svelte store. It also now caches the results
of the loader function so that it's not called multiple times for the same resource. You will most likely
benefit from quite a performance boost in applications that rely heavily on external resources.

### `useThrelteRoot` has been removed

The hook `useThrelteRoot` has been removed and its properties have partially been merged into `useThrelte` as well as
a new internal context which is not exposed. All other contexts (which were used internally) have also been merged or removed.

### `<Pass>` and the default effects rendering are removed

In the effort of clear separation of concerns, the component `<Pass>` as well as the rendering with Three.js default
`EffectComposer` have been removed. Threlte 6 now provides a hook called [`useRender`](/docs/reference/core/hooks#userender) which
allows you to easily set up sophisticated rendering pipelines. As soon as a `useRender` hook is implemented, Threlte's
default render pipeline is disabled. `useRender` callbacks will be invoked _after_ all callback to `useFrame` have been
invoked. This means that you can use `useFrame` to update your objects and `useRender` to render it. `useRender` also has the option of
ordering callbacks to orchestrate the rendering pipeline across multiple components.

### Threlte's main context types

Thelte's main context contains Svelte stores. These stores are now a custom Threlte store called
[`CurrentWritable`](/docs/reference/core/utilities#currentwritable) which is a store that contains a `current` value with
a reference to the current value of the store. This means it does not need to be unwrapped manually (and expensively!) in
non-reactive places such as loops. For instance, let's have a look at its usage in the hook
[`useFrame`](/docs/reference/core/hooks#useframe) where the context is available as the first argument
to the callback:

```ts
useFrame(({ camera, colorSpace }) => {
  // instead of get(camera) we now can …
  camera.current // THREE.Camera
  colorSpace.current // THREE.ColorSpace
})
```

The full type definition is [currently listed here](/docs/reference/core/hooks#usethrelte).

### `useGltfAnimations` Signature

The signature of the hook `useGltfAnimations` has changed. It no longer provides a callback that is invoked
when the `gltf` store has been populated and the `actions` store has been set. This is because it with the option to set
a custom root for the `THREE.AnimationAction`, the callback could be triggered multiple times, leading to an
unpredictable behavior. You should reside to using the `actions` store returned from the hook instead.

```ts
const { actions } = useGltfAnimations(gltf)
// this animation will play when the gltf store has been populated
// and the actions store has been set, effectively replacing the
// callback.
$: $actions.Greet?.play()
```

Check out the [hooks documentation](/docs/reference/extras/use-gltf-animations) for more information.

### `@threlte/rapier`

#### Transform props

In an effort to clearly separate concerns, the components `<Collider>`, `<AutoColliders>` and `<RigidBody>` **no longer
offer transform props** (`position`, `rotation`, `scale` and `lookAt`). Instead, you should wrap these components
in for instance `<T.Group>` components and apply transforms on these.

```svelte title="Before.svelte" {2,3}-
<Collider
  position={[0, 1, 0]}
  rotation={[0, 45 * DEG2RAD, 0]}
>
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>
</Collider>
```

```svelte title="After.svelte" {1-4,11}+
<T.Group
  position={[0, 1, 0]}
  rotation={[0, 45 * DEG2RAD, 0]}
>
  <Collider>
    <T.Mesh>
      <T.BoxGeometry />
      <T.MeshStandardMaterial />
    </T.Mesh>
  </Collider>
</T.Group>
```


================================================
File: apps/docs/src/content/learn/advanced/plugins.mdx
================================================
---
title: Plugins
category: Advanced
order: 0
---

Plugins allow you to extend Threlte's [`<T>`](/docs/reference/core/t)
component. They can be used to add props, event handlers, custom logic and
customize the component instance. You can think of a plugin as code that
is injected into every child `<T>` component.

Plugins can be overridden in child components.

The [interactivity plugin in
`@threlte/extras`](/docs/reference/extras/interactivity) is an example of what a
plugins can do and there are a couple of other examples below.

## When to use a Plugin

A plugin has access to all props and the lifecycle of the `<T>` component.

Use it to:

- add custom props to the `<T>` component such as [`lookAt`](#lookat).

- add custom logic to the `<T>` component, such as automatically add helpers for
  certain objects in DEV mode.

- collect object references from child components for app-wide systems such as
  an ECS.

- build custom integrations for external libraries.

<Tip type="tip" title="When to use oncreate">

[`<T>`'s `oncreate`](/docs/reference/core/t#create-event) shares some
similarities to a plugin but only has access to the object referenced by the
`<T>` component. Also, it has to be defined on every `<T>` component
individually.

You can think of `oncreate` as a [Svelte
Action](https://svelte.dev/docs/svelte/use) for `<T>` components. Use it for
one-time setup logic that does not need access to the component's props.

</Tip>

## Injecting a Plugin

Plugins are _injected_ to a plugin context and are **accessible to all child
`<T>` components**.

```svelte title="Scene.svelte"
<script>
  import { injectPlugin } from '@threlte/core'
  import myPlugin from './myPlugin'
  import OtherComponent from './OtherComponent.svelte'

  injectPlugin('my-plugin', myPlugin)
</script>

<!--
This component is affected by the plugin 'my-plugin'
-->
<T.Mesh />

<!--
<T> components in this component are
also affected by the plugin 'my-plugin'
-->
<OtherComponent />
```

### What it looks like

Plugins open up the component `<T>` to external code that will be injected via
context into every child instance of a `<T>` component. The callback function
receives a **reactive `args` object** that contains the `ref` of the respective
`<T>` component, all base props (`makeDefault`, `args`, `attach`, `manual`,
`makeDefault` and `dispose`) and all props (anything else) passed to it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('plugin-name', (args) => {
  console.log(args.ref) // e.g. a Mesh
  console.log(args.props) // e.g. { position: [0, 10, 0] }
})
```

If a plugin decides via `args.ref` or `args.props` analysis that it doesn't need
to act in the context of a certain `<T>` component, it can return early.

```ts
import { injectPlugin, isInstanceOf } from '@threlte/core'

injectPlugin('raycast-plugin', (args) => {
  if (!isInstanceOf(args.ref, 'Object3D') || !('raycast' in args.props)) return
})
```

The code of a plugin **acts as if it would be part of the `<T>` component
itself** and has access to all properties. A plugin can run arbitrary code in
lifecycle functions such as `onMount`, `onDestroy` and effects.

```ts
import { injectPlugin } from '@threlte/core'
import { onMount } from 'svelte'

injectPlugin('plugin-name', (args) => {
  // Use lifecycle hooks as if it would run inside a <T> component.
  // This code runs when the `<T>` component this plugin is injected
  // into is mounted.
  onMount(() => {
    console.log('onMount')
  })

  // Use any prop that is defined on the <T> component, in this
  // example `count`: <T.Mesh count={10} />
  const count = $derived(args.props.count ?? 0)

  $effect(() => {
    // This code runs whenever count changes.
    console.log(count)
  })

  return {
    // Claiming the property "count" so that the <T> component
    // does not act on it.
    pluginProps: ['count']
  }
})
```

A Plugin can also _claim properties_ so that the component `<T>` does not act on it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('ecs', () => {
  return {
    // Without claiming the properties, <T> would apply the
    // property to the object.
    pluginProps: ['entity', 'health', 'velocity', 'position']
  }
})
```

Plugins are passed down by context and can be overridden to prevent the effects of a plugin for a certain tree.

```ts
import { injectPlugin } from '@threlte/core'

// this overrides the plugin with the name "plugin-name" for all child components.
injectPlugin('plugin-name', () => {})
```

### Creating a Plugin

Plugins can also be _created_ for external consumption. This creates a _named plugin_. The name is used to identify the plugin and to override it.

```ts
import { createPlugin } from '@threlte/core'

export const layersPlugin = createPlugin('layers', () => {
  // ... Plugin Code
})
```

```ts
// somewhere else, e.g. in a component

import { injectPlugin } from '@threlte/core'
import { layersPlugin } from '$plugins'

injectPlugin(layersPlugin)
```

## Examples

### `lookAt`

This is en example implementation that adds the property `lookAt` to all `<T>` components, so that `<T.Mesh lookAt={[0, 10, 0]} />` is possible:

<Example path="plugins/lookAt" />

### BVH Raycast Plugin

A Plugin that implements [BVH raycasting](https://github.com/gkjohnson/three-mesh-bvh) on all child meshes and geometries.

```ts title="bvhRaycasting.svelte.ts"
import { injectPlugin, isInstanceOf } from '@threlte/core'
import type { BufferGeometry, Mesh } from 'three'
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'

const bvhRaycasting = () => {
  injectPlugin('bvh-raycast', (args) => {
    $effect(() => {
      if (isInstanceOf(args.ref, 'BufferGeometry')) {
        args.ref.computeBoundsTree = computeBoundsTree
        args.ref.disposeBoundsTree = disposeBoundsTree
        args.ref.computeBoundsTree()
      }
      if (isInstanceOf(args.ref, 'Mesh')) {
        args.ref.raycast = acceleratedRaycast
      }
      return () => {
        if (isInstanceOf(args.ref, 'BufferGeometry')) {
          args.ref.disposeBoundsTree()
        }
      }
    })
  })
}
```

Implementing this plugin in your Scene:

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import bvhRaycasting from './plugins/bvhRaycasting.svelte'

  bvhRaycasting()
</script>

<T.Mesh>
  <T.MeshBasicMaterial />
  <T.BoxGeometry />
</T.Mesh>
```

## TypeScript

Using TypeScript, we can achieve **end-to-end type safety for plugins**, from
the plugin implementation to the props of the `<T>` component. The example below
shows how to type the props of the [`lookAt` plugin](#lookat) so that the prop
`lookAt` is strictly typed on the `<T>` component as well as in the plugin
implementation.

### Typing a Plugin

The function `injectPlugin` accepts a type argument that you may use to type the
props passed to a plugin.

```ts
injectPlugin<{ lookAt?: [number, number, number] }>('lookAt', (args) => {
  // args.props.lookAt is now typed as [number, number, number] | undefined
})
```

### Typing the `<T>` Component Props

By default, the custom props of plugins are not present on the types of the
`<T>` component. You can however extend the types of the `<T>` component by
defining the `Threlte.UserProps` type in your ambient type definitions. In a
typical SvelteKit application, you can find these type definitions [in
`src/app.d.ts`](https://svelte.dev/docs/kit/types#app.d.ts).

```ts title="src/app.d.ts"
declare global {
  namespace App {
    // interface Error {}
    // interface Locals {}
    // interface PageData {}
    // interface PageState {}
    // interface Platform {}
  }

  namespace Threlte {
    interface UserProps {
      lookAt?: [number, number, number]
    }
  }
}

export {}
```

The prop `lookAt` is now available on the `<T>` component and is typed as
`[number, number, number] | undefined`.

```svelte title="Svelte.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
</script>

<!-- This is now type safe -->
<T.Mesh lookAt={[0, 10, 0]} />

<!-- This will throw an error -->
<T.Mesh lookAt="this object please" />
```

<Tip type="tip">
  As soon as your app grows in size, you should consider moving these type these type definitions to
  a separate file and merge all available props to a single type definition. This type may then be
  used by `injectPlugin` as well as your ambient type defintions.
</Tip>


================================================
File: apps/docs/src/content/learn/advanced/webgpu.mdx
================================================
---
category: Advanced
title: WebGPU and TSL
order: 1
---

<Tip type="experimental">
  The WebGPU specification is still in active development. WebGPU support in Three.js is in an early
  stage and is subject to frequent breaking changes. As of now, we do not recommend using WebGPU in
  production.
</Tip>

<Tip type="warning">
  We highly recommend targeting [version r171](https://github.com/mrdoob/three.js/releases/tag/r171)
  onwards because of potential [duplication and configuration
  issues](https://github.com/mrdoob/three.js/pull/29404).
</Tip>

## WebGPU

To use Three.js's WebGPU renderer, import it and then initialize it within your
`<Canvas>`'s `createRenderer` prop.

```svelte title="App.svelte" {4}+ {8-14}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas } from '@threlte/core'
  import { WebGPURenderer } from 'three/webgpu'
</script>

<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

<Tip type="note">
  WebGPU is still an experimental browser api and at the time of writing has [limited availability
  across major browsers](https://caniuse.com/?search=webgpu). For this reason, Three.js's webgpu
  renderer fallbacks to webgl when webgpu is not available.
</Tip>
<Tip type="tip">
  This same approach can be used to swap out the default renderer for any other custom renderer.
</Tip>

<Example path="renderers/WebGPU" />

<small>
  Adapted from [this Three.js
  example](https://threejs.org/examples/?q=webgpu#webgpu_performance_renderbundle).
</small>

The WebGPU renderer doesn't immediately render. If the renderer you provide needs to delay rendering, you
can defer rendering by initially setting the renderMode to `manual` like so:

```svelte title="App.svelte"
<script>
  import { Canvas, T } from '@threlte/core'
  import { WebGPURenderer } from 'three/webgpu'
  let renderMode = $state('manual')
</script>

<Canvas
  {renderMode}
  createRenderer={(canvas) => {
    const renderer = new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
    renderer.init().then(() => {
      renderMode = 'on-demand'
    })
    return renderer
  }}
>
  <Scene />
</Canvas>
```

### Vite

WebGPU uses top-level async to determine WebGPU compatibility. Vite
will often throw an error when it detects this.

To circumvent this issue, the following can be added to your Vite config.

```js
// vite.config.js
optimizeDeps: {
  esbuildOptions: {
    target: 'esnext'
  }
},
build: {
  target: 'esnext'
}
```

Alternatively,
[`vite-plugin-top-level-await`](https://github.com/Menci/vite-plugin-top-level-await)
can be used, although less success has been reported with this method.

## TSL

A question that comes up often in Three.js development is "How do I extend Three.js's materials?".
External libraries such as [three-custom-shader-material](https://www.npmjs.com/package/three-custom-shader-material)
use a find and replace solution to get this job done. Three.js has identified
that it's not an ideal solution and recommends using the [Three.js Shading Language](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language) or TSL for short.

The example below is an adaptation of [this](https://threejs.org/examples/?q=tsl#webgpu_tsl_angular_slicing)
Three.js example. There are many more [TSL examples](https://threejs.org/examples/?q=tsl)
within Three.js that you can use or adapt for your project.

<Example path="shaders/slice/main" />

### Using the \<T> catalogue

The `<T>` component uses all the exports from `three`. It will error on things like
`<T.MeshPhysicalNodeMaterial />` because the `MeshPhysicalNodeMaterial` class is an
export of `three/webgpu` not `three`. You have a few options to work this out.

1. Extend `<T>` with all the definitions from `three/webgpu` by using the [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue)
   function. Adding all of the definitions will increase the bundle size of your application because both `three` and `three/webgpu` will be imported in a non-tree-shakeable way.

```svelte title="App.svelte" {3-4}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import * as THREE from 'three/webgpu'

  extend(THREE)
</script>

<Canvas
  createRenderer={(canvas) => {
    return new THREE.WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

2. Use explicit imports for the objects, functions, and other classes that you use from `three/webgpu`.
   You can then use `<T>`'s [`is`](/docs/reference/core/t#property-is) prop with those imports from `three/webgpu`.

```svelte title="Scene.svelte" {3}+ {5}+ {10}+
<script>
  import { T } from '@threlte/core'
  import { MeshPhysicalNodeMaterial } from 'three/webgpu'

	const material = new MeshPhysicalNodeMaterial()
</script>

<T.Mesh>
	<T.BoxGeometry>
	<T is={material}>
</T.Mesh>
```

3. Same as option #2 but using [`extend`](/docs/reference/core/t#extending-the-default-component-catalogue) with the imports so that you can have `<T.MeshPhysicalNodeMaterial />` etc...

```svelte title="App.svelte" {3-4}+ {6}+
<script>
  import Scene from './Scene.svelte'
  import { Canvas, extend } from '@threlte/core'
  import { WebGPURenderer, MeshPhysicalNodeMaterial } from 'three/webgpu'

  extend({ MeshPhysicalNodeMaterial })
</script>

<Canvas
  createRenderer={(canvas) => {
    return new WebGPURenderer({
      canvas,
      antialias: true,
      forceWebGL: false
    })
  }}
>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshPhysicalNodeMaterial />
</T.Mesh>
```

Options 2 and 3 will keep the bundle size of your application small but you'll have to keep it updated as you go.

#### Careful! `three` and `three/webgpu` don't mix well

You will need to overwrite some of the default `<T>` catalogue if you use `three/webgpu`.
For example, if you're using a `MeshPhysicalNodeMaterial`, you need to update any lighing classes you use like so:

```svelte title="App.svelte"
<script>
  import { DirectionalLight, MeshPhysicalNodeMaterial } from 'three/webgpu'

  // tell <T.DirectionalLight> to use the definition from `three/webgpu`
  extend({ MeshPhysicalNodeMaterial, DirectionalLight })
</script>

<Canvas>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T } from '@threlte/core'
</script>

<T.DirectionalLight />

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshPhysicalNodeMaterial />
</T.Mesh>
```

This is because the exports from `three/webgpu` are different than those in `three` and make use of the additional features that node materials have.

<Tip type="tip">
  An easy option for projects is to start with option #1 and then transition to the other options
  when bundle size becomes an issue or you need to ship to production.
</Tip>

### Nodes

The [nodes](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#nodematerial) can be directly assigned like any other prop on the `<T>` component.

```svelte
<T.MeshPhysicalNodeMaterial
  outputNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg1, arg2)}
  shadowNode={Fn(([arg1, arg2]) => {
    /* ... */
  })(arg2, arg2)}
/>
```

Node materials give you the ability to modify three's builtin materials.
In the sliced gear example, two nodes are modified; the `outputNode` and the `shadowNode`.
The `outputNode` is set up in such a way that it discards any fragments that are
outside the permitted `startAngle` and `arcAngle`. If a fragment is not discarded and
it is not front-facing, it is assigned the color in the `color` uniform. The material
needs its `side` set to `THREE.DoubleSide` otherwise three.js will cull them out if they are facing away
from the camera,

Any fragment that is discarded in the shadowNode will not cast shadows.

### Updating Uniforms

If your node uses uniforms, they can be declared in the `script` tag of
the component and updated via `$effect` or a callback.

For example, if your material uses elapsed time in a uniform, you can update the
uniform inside a `useTask` callback.

The material in the example below demonstrates two ways to update uniforms. The `uTime` uniform
is updated in `useTask` whereas `uIntensity` is updated in an `$effect`.

<Example path="shaders/slice/updatingUniforms" />

<Tip type="info">
  Note that TSL has an
  [`oscSine`](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language#oscillator) function
  that oscillates on time that could also be used in the example above.
</Tip>


================================================
File: apps/docs/src/content/learn/basics/app-structure.mdx
================================================
---
category: Basics
title: App Structure
order: -900
---

Threlte makes heavy use of [Svelte's Context
API](https://svelte.dev/tutorial/context-api) as a way to pass data through the
component tree without having to pass props down manually at every level:

```svelte title="SomeComponent.svelte"
<script>
  const { camera, renderer } = useThrelte()
</script>
```

To let Threlte do its magic, we recommend to follow our best practices for
structuring your app.

## Recommended App Structure

The [`<Canvas>`](/docs/reference/core/canvas) component provides all basic contexts in a Threlte application.
The recommended app structure is to have a single child component of `<Canvas>` (typically named "Scene.svelte" in examples) for
your Threlte app. This will allow contexts provided by `useThrelte` and other hooks to be used.

```svelte title="App.svelte"
<script>
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
```

```svelte title="Scene.svelte"
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import Player from './Player.svelte'
  import World from './World.svelte'

  let rotation = 0

  // useTask is relying on a context provided
  // by <Canvas>. Because we are definitely *inside*
  // <Canvas>, we can safely use it.
  useTask((delta) => {
    rotation += delta
  })

  // This file is also typically the place to
  // inject plugins
  interactivity()
</script>

<T.Mesh rotation.y={rotation}>
  <T.BoxGeometry />
  <T.MeshBasicMaterial color="red" />
</T.Mesh>

<Player />
<World />
```

## Context Not Available

<Tip type="danger">
	The following app structure is deceiving. It looks like it should work, but **it
	will not**. The problem is that the `useTask` hook is called *outside* of the
	`<Canvas>` component, so the main Threlte context is not available. Usually hooks
	relying on some context will tell you with descriptive error messages when they
	are used outside of their context.
</Tip>

```svelte title="App.svelte"
<script>
  import { Canvas, useTask, T } from '@threlte/core'

  let rotation = 0

  // This won't work, we're not inside <Canvas>
  useTask((delta) => {
    rotation += delta
  })
</script>

<Canvas>
  <T.Mesh rotation.y={rotation} />
</Canvas>
```


================================================
File: apps/docs/src/content/learn/basics/disposing-objects.mdx
================================================
---
title: Disposing Objects
category: Basics
order: -400
---

Freeing resources is a [manual chore in
three.js](https://threejs.org/docs/index.html#manual/en/introduction/How-to-dispose-of-objects),
but Svelte is aware of component lifecycles, hence Threlte will attempt to free
resources for you by calling `dispose`, if present, on all unmounted objects
that are not being used anywhere else in your scene.

## Automatic Disposal

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'
</script>

<!--
	The geometry and the material will be disposed
	as soon as the <Mesh> component unmounts.
-->
<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial />
</T.Mesh>
```

<Tip>
  Be aware that calling `dispose` on a three.js buffer, material or geometry is merely deallocating
  it from the GPU memory. If an object is used after it's disposed it will be allocated again,
  resulting in a performance drop for a single frame. It will **not produce a runtime error**.
</Tip>

## Manual Disposal

You can switch off automatic disposal by placing `dispose={false}` onto
components. This disables disposal for the entire subtree.

```svelte
<script>
  import { T, useTexture } from '@threlte/core'

  const map = useTexture('/some/texture')
  const material = new MeshStandardMaterial({ map })
</script>

<!-- will not be disposed -->
<T.Mesh dispose={false}>
  <!-- will not be disposed -->
  <T.BoxGeometry />
  <!-- will not be disposed -->
  <T.MeshStandardMaterial map={$map} />

  <!-- will be disposed -->
  <T.Mesh dispose>
    <!-- will be disposed -->
    <T.BoxGeometry />
    <!-- will be disposed -->
    <T.MeshStandardMaterial map={$map} />
  </T.Mesh>
</T.Mesh>
```

## Custom Disposal

You can use the return function of the `oncreate` prop to dispose of objects manually.

```svelte
<script>
  import { T } from '@threlte/core'
</script>

<T.MeshBasicMaterial
  oncreate={(ref) => {
    return () => {
      // Do your disposal here
    }
  }}
/>
```

## Automatic Disposal Limitations

Be aware that automatic disposal only happens on the objects that are referenced
by a `<T>` component.

```svelte
<script>
  import { T } from '@threlte/core'
  import { useTexture } from '@threlte/extras'

  const map = useTexture('/some/texture.png')
</script>

{#if $map}
  <T.Mesh>
    <T.BoxGeometry />
    <T.MeshBasicMaterial map={$map} />
  </T.Mesh>
{/if}
```

In this example, the texture will not be disposed when the material unmounts,
you will have to dispose of it manually.


================================================
File: apps/docs/src/content/learn/basics/handling-events.mdx
================================================
---
title: Handling Events
category: Basics
order: -700
---

Events come in three different flavours in Threlte. The DOM events you know from
HTML, some svelte [component props](https://svelte.dev/docs/svelte/basic-markup#Component-props)
and raycasting.

## DOM events

To get started, you'll need an HTML element. The [`useThrelte`](/docs/reference/core/use-threlte)
hook provides you with direct access to Threltes HTML div wrapper - the `dom`.
The `canvas` is also available if that is more appropriate for your events.

## Prop events

The `<T>` component has it's own [events](/docs/reference/core/t#events). It can even pickup
on events coming from the [underlying three.js objects](/docs/reference/core/t#object-events).

## Raycasting events

Casting rays can end up being a big part of your 3D application. They're required for
creating [`interactivity`](/docs/reference/extras/interactivity) (click, pointer
and wheel events) on your scene's meshes. Raycasting can struggle with complex shapes
or a high number of objects but this can be mitigated by either:

- Raycasting against an simplier, invisible object ([a sphere](/docs/reference/extras/mesh-bounds) for example)
- Or introducing a better raycasting algorithm such as Bounding Volume Hirerchies ([BVH](/docs/learn/advanced/plugins#bvh-raycast-plugin))

In general, Three.js's default raycaster works well enough.


================================================
File: apps/docs/src/content/learn/basics/loading-assets.mdx
================================================
---
category: Basics
title: Loading Assets
order: -750
---

There are a number of different asset types you might like to use in your Threlte application. Three.js has a [ton of different loaders](https://threejs.org/docs/index.html?q=loader) that Threlte integrates well with. You're recommended to use the [useLoader](/docs/reference/core/use-loader) hook which will cache any asset it loads and wrap the asset in an [asyncWritable](/docs/reference/core/utilities#asyncwritable) for convenience. Caching assets will reduce network requests, bandwidth, and memory usage, which will improve the performance of your application.

<Tip type="info">
  This section assumes you placed your assets in your public folder or in a place in your
  application where you can import them easily.
</Tip>

## Models

Models come in many different formats. For example, `.gltf`'s are mostly json files. You can use three's `GLTFLoader` to load a `.gltf` model.

```svelte
<script>
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
  import { useLoader } from '@threlte/core'

  const gltf = useLoader(GLTFLoader).load('/assets/model.gltf')
</script>

{#if $gltf}
  <T is={$gltf.scene} />
{/if}
```

The [`<GLTF/>`](/docs/reference/extras/gltf) component is roughly equivalent to the example above.

### Convenient: useGltf

`@threlte/extras` provides a handy hook for loading `.gltf` models called [useGltf](/docs/reference/extras/use-gltf):

```svelte
<script>
  import { useGltf } from '@threlte/extras'
</script>

{#await useGltf('/assets/model.gltf') then gltf}
  <T is={gltf.scene} />
{/await}
```

### Adjusting Parts and Multiple Copies

There are some challenges you'll probably run into when working with models in Threlte:

- Your model may have multiple parts that you'd like to adjust individually but there's no easy way to declaritively achieve that with only one `<T/>` component.
- The model is cached which is great but you can't seem to place multiple copies in your scene.

To address both of these issues, you can use Threlte's CLI tool [@threlte/gltf](/docs/reference/gltf/getting-started) to generate a svelte component for your model. The generated component has `<T/>` components for all of your models parts. [Adjust the component](/docs/learn/advanced/custom-abstractions) to your liking, then import and reused it as much as you'd like.

### Animations

Three.js uses [AnimationMixer](https://threejs.org/docs/index.html#api/en/animation/AnimationMixer) to drive animations. Threlte provides a convenient [useGltfAnimations](/docs/reference/extras/use-gltf-animations) hook for gltf's. See the [three.js examples](https://threejs.org/examples/?q=animation) for how to setup a model for your animation needs.

Threlte has a few [animation examples](/docs/examples/animation/animation-transitions) to help you get started.

## Textures

The `TextureLoader` is another loader from three that is used for textures.

```svelte
<script>
  import { TextureLoader } from 'three'
  import { useLoader } from '@threlte/core'

  const texture = useLoader(TextureLoader).load('/assets/texture.png')
</script>

{#if $texture}
  <T.MeshStandardMaterial map={$texture} />
{/if}
```

### Convenient: useTexture

`@threlte/extras` provides a handy hook for loading textures called [useTexture](/docs/reference/extras/use-texture):

```svelte
<script>
  import { useTexture } from '@threlte/extras'
</script>

{#await useTexture('/assets/texture.png') then texture}
  <T.MeshStandardMaterial map={texture} />
{/await}
```

### Multiple textures

Sometimes you'll want your materials to be composed of multiple textures. `useLoader` provides a way to load multiple textures at once and [spread](https://learn.svelte.dev/tutorial/spread-props) the loaded textures on a material.

Loading two textures for the `map` and `normalMap` channels can be done like this:

```ts
const textures = useLoader(TextureLoader).load({
  map: '/assets/texture.png',
  normalMap: '/assets/normal.png'
})
```

or with the `useTexture` hook:

```ts
const textures = useTexture({
  map: '/assets/texture.png',
  normalMap: '/assets/normal.png'
})
```

Then spread on a material:

```svelte
{#if $textures}
  <T.MeshStandardMaterial {...$textures} />
{/if}
```

If multiple textures are given, the promise only resolves once all textures have loaded.

### Applying different textures to different faces

To declaratively apply two different textures to two different faces of a `BoxGeometry`, set the `attach` prop to a function.

```svelte
<T.Mesh>
  <T.BoxGeometry />
  <T.MeshStandardMaterial
    map={texture1}
    attach={({ parent, ref }) => {
      if (Array.isArray(parent.material)) parent.material = [...parent.material, ref]
      else parent.material = [ref]
    }}
  />
  <T.MeshStandardMaterial
    map={texture2}
    attach={({ parent, ref }) => {
      if (Array.isArray(parent.material)) parent.material = [...parent.material, ref]
      else parent.material = [ref]
    }}
  />
</T.Mesh>
```

Alternatively, mix declarative and normal three.js code like so for the same result:

```svelte
<script>
  // imports and other code
  const customMaterials = [
    new MeshStandardMaterial({ map: texture1 }),
    new MeshStandardMaterial({ map: texture2 })
  ]
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T
    is={customMaterials}
    attach="material"
  />
</T.Mesh>
```

## Other Assets

Threlte provides many components to help get started with other assets (like [audio](/docs/reference/extras/audio)) but we don't have convenient components and hooks for all of them yet. Checkout [three.js examples](https://threejs.org/examples/) to see what models, techniques and effects you can acheive, then use those examples as a guide for your own [custom components](/docs/learn/advanced/custom-abstractions).

## Async Loading

The return value from [useLoader](/docs/reference/core/use-loader) is an `AsyncWritable` custom store. Its value will be `undefined` until the asset has loaded.

Since the underlying store's value is a promise, you can use it within svelte's await blocks:

```svelte
{#await $texture then value}
  <T.MeshStandardMaterial map={value} />
{/await}
```

These hooks can be used similarly to Svelte's `onMount` hook however assets can also be loaded after initialization by separating out the load call:

```svelte
<script>
  import { AudioLoader } from 'three'
  import { useLoader } from '@threlte/core'

  // Instantiate the loader at component initialization
  const loader = useLoader(AudioLoader)

  const onSomeEvent = async () => {
    // Load the asset when needed
    const audioBuffer = await loader.load('/assets/sound.mp3')
  }
</script>
```

Another set of tools to help orchestrate loading multiple assets before displaying something is the [suspense](/docs/reference/extras/suspense) component and hooks.

## Context Awareness

The `useLoader` hook, and other hooks like `useTexture`, use svelte contexts. The assets loaded with them are only available for child components of your `<Canvas>` component.


================================================
File: apps/docs/src/content/learn/basics/render-modes.mdx
================================================
---
category: Basics
title: Render Modes
order: -450
---

Threlte offers three different render modes to optimize the performance and
power usage of your Threlte app. Ideally, you only want to render the scene
when it is necessary, such as when the camera moves or when objects are added or
removed from the scene. The render mode determines how and when the scene is
rendered.

In the default [`'on-demand'`](#mode-on-demand) mode, Threlte is able to
determine when a re-render is necessary by observing components. When setting
the render mode to [`'manual'`](#mode-manual) you must manually trigger a
re-render. You can tell Threlte to continuously render the scene in the
[`'always'`](#mode-always) mode.

## Mode `'on-demand'`

<Example path="renderers/on-demand-rendering" />

In the mode `'on-demand'`, Threlte renders the scene only when the current frame
is **invalidated**. This may happen [automatically when changes are
detected](#automatic-invalidation) or the frame is [manually
invalidated](#manual-invalidation). This is the default mode and the recommended
way of working with Threlte.

### Automatic Invalidation

Threlte is able to automatically invalidate the current frame by observing
component props and the mounting and unmounting of components. This means that
when you e.g. change the position of a `<T.Mesh>` via component props, Threlte
will automatically invalidate the current frame and request a new frame.

```svelte
<script>
  import { T } from '@threlte/core'

  let x = 0

  const move = () => {
    x += 1
  }
</script>

<T.Mesh position.x={x} />
```

### Manual Invalidation

In some cases, you may want to manually invalidate the current frame because
Threlte is not able to detect changes. To do this, you can use the `invalidate`
function from the [`useThrelte`](/docs/reference/core/use-threlte) hook.

```svelte
<script>
  import { T, useThrelte } from '@threlte/core'
  import { Mesh } from 'three'

  const { invalidate } = useThrelte()

  const mesh = new Mesh()

  export const moveMesh = () => {
    // moving the mesh manually
    mesh.position.x = 1
    // invalidate the current frame
    invalidate()
  }
</script>

<T is={mesh} />
```

### `useTask`

The [`useTask`](/docs/reference/core/use-task) hook is by default configured to
automatically invalidate the current frame **on every frame**. This means that you
can use it to animate your scene without having to manually invalidate the
current frame.

```ts
import { useTask } from '@threlte/core'

useTask(() => {
  // useTask will automatically invalidate the current
  // frame, so you don't have to do it manually.
})
```

Sometimes you may want to manually invalidate the current frame from within a
task. To do this, you can use the `invalidate` function from the
[`useThrelte`](/docs/reference/core/use-threlte) hook and set the `autoInvalidate`
option to `false`:

```ts
import { useTask, useThrelte } from '@threlte/core'

const { invalidate } = useThrelte()

useTask(
  () => {
    // Because `autoInvalidate` is set to `false`, the current
    // frame will not be invalidated automatically and you can
    // conditionally invalidate the current frame.
    invalidate()
  },
  { autoInvalidate: false }
)
```

## Mode `'manual'`

In the manual mode, you must manually trigger a re-render:

```ts
const { advance } = useThrelte()
advance()
```

This mode is useful when you want to have full control over when the scene is
rendered. For example, you may want to render the scene only when the user
interacts with the scene.

## Mode `'always'`

In the `'always'` mode, Threlte continuously renders the scene. This mode is the
easiest to use, but it is also the most resource intensive and should only be
used when necessary.

## Setting the Render Mode

### `<Canvas>` Prop

You can set the render mode by setting the property `renderMode` on the
[`<Canvas>`](/docs/reference/core/canvas) component:

```svelte
<Canvas renderMode="on-demand" />
```

### `useThrelte` Hook

You can also set the render mode from anywhere within your Threlte app using the
[`useThrelte`](/docs/reference/core/use-threlte) hook:

```ts
const { renderMode } = useThrelte()
renderMode.set('on-demand')
```

<Tip type="tip">
  The renderMode property can be changed at any time, but it will only take effect on the next
  frame.
</Tip>

## Render Modes and Custom Rendering

By default, Threlte will automatically render the scene for you. In some cases,
you may want to render the scene yourself, for example when using [post
processing](/docs/examples/postprocessing/outlines).

1. Set `autoRender` to `false` on the [`<Canvas>`](/docs/reference/core/canvas)
   component. This will prevent Threlte from automatically rendering the scene
   and you can render the scene yourself.

```svelte
<Canvas autoRender={false} />
```

2. Set up a task that renders the scene. There are two ways to do this:

- Add a task to [Threlte's default
  `renderStage`](/docs/learn/basics/scheduling-tasks#default-stages). Tasks in
  that stage will be executed after tasks in Threlte's `mainStage` and only
  when a re-render is necessary based on the current render mode. This is the
  recommended approach.

```ts
import { useTask, useThrelte } from '@threlte/core'

const { renderStage } = useThrelte()

useTask(
  () => {
    // render here
  },
  { stage: renderStage, autoInvalidate: false }
)
```

- Use `shouldRender` from the hook
  [`useThrelte`](/docs/reference/core/use-threlte). This function will evaluate
  to `true` based on the current render mode. This allows for more fine-grained
  control over when to render and is useful when you want to render in a task
  that is not in [Threlte's default
  `renderStage`](/docs/learn/basics/scheduling-tasks#default-stages).

```ts
import { useThrelte, useTask } from '@threlte/core'

const { shouldRender } = useThrelte()

useTask(
  () => {
    if (shouldRender()) {
      // render here
    }
  },
  { autoInvalidate: false }
)
```


================================================
File: apps/docs/src/content/learn/basics/scheduling-tasks.mdx
================================================
---
title: Scheduling Tasks
category: Basics
order: -500
---

In 3D apps and games, a lot of work is done in functions that run on every frame.
Web-based apps rely on the browser's `requestAnimationFrame` that runs a callback
function when a new frame is rendered. When encapsulating logic into smaller
parts (i.e. _components_), we often need to run multiple
callbacks that may be dependent on each other. For instance, we
may want to update the position of an object based on user input and then render
the scene with the updated position.

In Threlte, these functions are called **tasks** and may or may not follow a
specific order. If an order is specified, the respective task has a
**dependency** to other tasks and vice versa. Tasks are grouped into **stages**
and follow the same logic: They may or may not have dependencies to other stages
to be executed in a specific order. A Threlte app is managed by a single
**scheduler**.

In this section, we will learn how to use the easy-to-use tools that the
**Threlte Task Scheduling System** provides to create and orchestrate stages
and tasks.

<img
  class="w-full max-md:hidden"
  src="/images/docs/learn/frame-handling.svg"
/>
<img
  class="mx-auto h-[85vh] w-auto md:hidden"
  src="/images/docs/learn/frame-handling_portrait.svg"
/>

<small>Figure: A schedule of multiple stages with tasks</small>

## Scheduler

Every Threlte app has a single scheduler. It is accessible via [`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { scheduler } = useThrelte()
```

<Tip type="info">
  Usually you won't need to interact with the scheduler directly. It is used internally by Threlte.
  However, you can use it to create stages and run tasks manually for more advanced use cases.
</Tip>

## Stages

Stages are **groups of tasks**. They are executed in a specific order.

### Default Stages

By default, Threlte will create two stages for you:

- **`mainStage`**: This stage holds all the tasks that are not assigned to any
  other stage.
- **`renderStage`**: This stage will be executed after the `mainStage`. It is
  used to render the scene and only ever executes its tasks when a re-render is
  needed.

These two stages are created automatically and are accessible via
[`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { mainStage, renderStage } = useThrelte()
```

### Creating a Stage

Sometimes, you may want to create your own stage, for instance to run tasks
after rendering. You can do so by using the hook `useStage`. The hook will
create a stage if it does not exist yet, or return the existing stage if it
does.

```ts
const { renderStage } = useThrelte()

const afterRenderStage = useStage('after-render', {
  after: renderStage
})
```

All tasks added to the stage `afterRenderStage` will be executed after the tasks
of the stage `renderStage`.

<Tip type="tip">Be aware that `useStage` never removes a stage as that's usually not needed.</Tip>

A stage decides **when and how its tasks are executed**. By default, a stage will
execute its tasks on every frame. You can change this behavior by passing a
`callback` option to `useStage`. This callback will be called every frame. The
first argument `delta` is the time elapsed since the last frame. The second
argument `runTasks` is a function that when invoked will run all the tasks of
the stage in their respective order. You can use it to run the tasks only when
needed (e.g. when a condition is met) or to run them multiple times. If a number
is passed as the first argument to runTasks, the tasks will receive that as the
delta.

```ts
const { renderStage } = useThrelte()

const conditionalStage = useStage('after-render', {
  after: renderStage,
  callback: (delta, runTasks) => {
    // This callback will be called every frame. The first argument is the time elapsed
    // since the last frame. The second argument is a function that will run all the
    // tasks of the stage. You can use it to run the tasks only when needed (e.g. when
    // a condition is met) or to run them multiple times. If a number is passed as the
    // first argument to runTasks, the tasks will receive that as the delta.
    if (condition) {
      runTasks()
    }
  }
})
```

### Removing a Stage

You can remove a stage by calling the `remove` method of the scheduler. The first
argument is the stage or the key of the stage to remove.

```ts
const { scheduler } = useThrelte()

scheduler.removeStage(afterRenderStage)
```

<Tip>
  Be aware that removing a stage will also remove all the tasks in that stage. Usually, you won't
  need to remove a stage.
</Tip>

## Tasks

Tasks are functions that are executed on every frame. They are grouped in
stages. You can add a task to a stage by using the hook `useTask`. The hook will
create a task and add it to a stage.

### Default Tasks

By default, Threlte will create a single task for you:

- **`autoRenderTask`**: This task is part of [Threlte's
  `renderStage`](#default-stages) and will render the scene if
  [`autoRender`](/docs/reference/core/canvas) is set to `true`.

This task is created automatically and is accessible via
[`useThrelte()`](/docs/reference/core/use-threlte):

```ts
const { autoRenderTask } = useThrelte()
```

### Creating an Anonymous Task

In its most basic form, `useTask` takes a function as its first argument. This
function will be executed on every frame, starting on the next frame and
receives the delta time representing the time since the last frame as its first
argument. By default, the created task is added to [Threlte's
`mainStage`](#default-stages) in an arbitrary order (i.e. without dependencies).

```ts
const { start, stop, started, task } = useTask((delta) => {
  // This function will be executed on every frame
})
```

It returns an object with the following properties:

- `start`: A function that starts the task. It will be executed on the next
  frame. Note that by default a task is started automatically.
- `stop`: A function that stops the task. It will not be executed on the next
  frame.
- `started`: A boolean Svelte `Readable` store indicating whether the task is
  started or not.
- `task`: The task itself. You can use it to indicate a dependency to this task
  on another task.

### Creating a Keyed Task

You can _key_ a task by passing it as the first argument to `useTask`. This
makes referencing this task easier across your app. The key can be any `string`
or `symbol` value that is unique across all tasks in the stage it is added to.

```ts
const {
  start,
  stop,
  started,
  task: someTask
} = useTask('some-task', (delta) => {
  // This function will be executed on every frame
})
```

### Creating a Task in a Stage

You can also pass a stage that the task should be added to as an option to
`useTask`:

```ts
useTask(
  (delta) => {
    // This function will be executed on every frame as a
    // task in the stage `afterRenderStage`.
  },
  { stage: afterRenderStage }
)
```

### Task Dependencies

A common use case for tasks is to run code after another task has been executed. Imagine
a game where an object is transformed by user input in one task and a camera follows that
object in another task. The camera task should be executed after the object has been
transformed.

To control the order in which tasks are executed in a stage, you can pass a
`before` and `after` option to `useTask`. The tasks passed to these options are
called **dependencies** and can be a task itself, the key of a task or an array
of tasks or keys. The referenced tasks must be in the same stage as the task you
are creating.

Task dependencies **do not need to be created yet** if they are passed by key.
The declared dependencies will be taken into account when they are created later
on.

#### Examples

```ts
// Execute a task after a single task passed by reference
useTask(
  (delta) => {
    // …
  },
  { after: someTask }
)
```

```ts
// Execute a task after a single task passed by key
useTask(
  (delta) => {
    // …
  },
  { after: 'some-task' }
)
```

```ts
// Execute a task after multiple tasks passed by reference
useTask(
  (delta) => {
    // …
  },
  { after: [someTask, someOtherTask] }
)
```

```ts
// Execute a task after a certain task but before another one
useTask(
  (delta) => {
    // …
  },
  { after: someTask, before: someOtherTask }
)
```

```ts
// Reference a task as a dependency that hasn't been created yet
useTask(
  (delta) => {
    // If a task with the key `some-task` is created later on,
    // this task will be executed after it.
  },
  { before: 'some-task' }
)

useTask('some-task', (delta) => {
  // …
})
```

<Tip type="warning">
  If a task is passed by reference to the `before` or `after` option, the task created by `useTask`
  will automatically be added to the same stage as the task it depends on. If you pass a key instead
  and the task you want to reference is **not** in [Threlte's `mainStage`](#default-stages), you
  will also need to pass the stage, either by value or key.
</Tip>

## Reviewing the schedule

To debug the execution order, you can use the `getSchedule` method of the scheduler at any
time.

```ts
const { scheduler } = useThrelte()

scheduler.getSchedule({
  tasks: true
})
```

```json title="Result"
{
  "stages": [
    {
      "key": "physics stage",
      "tasks": ["physics"]
    },
    {
      "key": "main stage",
      "tasks": ["move object", "move camera"]
    },
    {
      "key": "render stage",
      "tasks": ["render"]
    }
  ]
}
```

In this example, the effective task execution order is:

1. `physics`
2. `move object`
3. `move camera`
4. `render`

---

The design of the Threlte Task Scheduling System is a collaborative effort of
the Threlte team, [Kris Baumgarter](https://github.com/krispya) and [Akshay
Dhalwala](https://github.com/akdjr).


================================================
File: apps/docs/src/content/learn/getting-started/installation.mdx
================================================
---
category: Getting Started
title: Installation
---

import ManualInstallGuide from '$components/ManualInstallGuide/ManualInstallGuide.svelte'

To start using Threlte install the packages you want to use in your project.

Threlte consists of 7 packages which can be installed and used individually.
`@threlte/core` and Three.js itself are required for all projects while the
other packages are optional.
[`@threlte/gltf`](/docs/reference/gltf/getting-started) does not need to be
installed separately as it can be used with `npx`, the resulting Threlte
components however require `@threlte/extras` to be installed.

### Choose the packages you want to use

<ManualInstallGuide client:load />

<Tip type="tip">
  [See this comment](https://github.com/threlte/threlte/issues/8#issuecomment-1024085864) for tips
  on how to reduce bundle size when working with bundlers like vite and three.js.
</Tip>


================================================
File: apps/docs/src/content/learn/getting-started/introduction.mdx
================================================
---
category: Getting Started
title: Introduction
order: -999
---

<Tip type="tip">
  If you're looking for the documentation for Threlte 7, head to
  [v7.threlte.xyz](https://v7.threlte.xyz).
</Tip>

Threlte is a renderer and component library for using Three.js in a **declarative** and **state-driven** way in Svelte apps. It provides strictly typed components for deep **reactivity** and **interactivity** out-of-the-box.

Threlte is comprised of six distinct packages to allow you to import only what you need:

- [@threlte/core](/docs/reference/core/getting-started) is the heart of Threlte, providing simple transparent Svelte binding to Three.js:

  - [`<T>`](/docs/reference/core/t) is the **main building block** of any Threlte application. It is a thin wrapper around any Three.js
    object and provides a declarative API to build and render your Threlte app.

  - [Plugins](/docs/learn/advanced/plugins) make it easy to extend Threlte with custom code and logic. Whether you want to implement an ECS or add a single property to every instance of `<T>`, plugins are the way to go.

- [@threlte/extras](/docs/reference/extras/getting-started) is a collection of plugins and components that extend Threlte with additional functionality.

- [@threlte/gltf](/docs/reference/gltf/getting-started) is a command-line tool that turns GLTF assets into declarative and re-usable Threlte components.

- [@threlte/rapier](/docs/reference/rapier/getting-started) provides components to enable performant physics in your Threlte application through the [Rapier engine](https://rapier.rs/)

- [@threlte/theatre](/docs/reference/theatre/getting-started) provides components to enable animations in your Threlte application through the [Theatre.js animation library](https://www.theatrejs.com/)

- [@threlte/xr](/docs/reference/xr/getting-started) provides components for VR and AR.

- [@threlte/flex](/docs/reference/flex/getting-started) provides components to easily use the flex engine [`yoga-layout`](https://yogalayout.com/) with Threlte.


================================================
File: apps/docs/src/content/learn/getting-started/your-first-scene.mdx
================================================
---
category: Getting Started
title: Your First Scene
---

<Tip type="info">
  You should be versed in both Svelte and Three.js before rushing into Threlte. If you are unsure
  about Svelte, consult its [Tutorial](https://svelte.dev/tutorial) for a quick introduction. As for
  Threejs, make sure you at least glance over its [official documentation](https://threejs.org).
</Tip>

## Structuring Your App

As a first step we're creating a new Svelte file called `App.svelte` where we are importing the [`<Canvas>` component](/docs/reference/core/canvas).

```svelte title="App.svelte"
<script>
  import { Canvas } from '@threlte/core'
  import Scene from './Scene.svelte'
</script>

<Canvas>
  <Scene />
</Canvas>
```

The `<Canvas>` component is the root component of your Threlte application. It creates a
renderer and sets up some sensible defaults for you like antialiasing and color management.
It also creates a default camera and provides the context in which your Threlte application
will run. For improving access to this runtime context, it's <a href="/docs/learn/basics/app-structure">best practice</a>
to create a seperate component called `Scene.svelte` and including it in our `App.svelte` file.

## Creating Objects

At this point we're looking at a blank screen. Let's add a simple cube to it.

In `Scene.svelte`, we're importing the [`<T>` component](/docs/reference/core/t) which is
the **main building block** of your Threlte application. It's a **generic
component** that we use to render **any Three.js object**. In this case we're creating a
[`THREE.Mesh`](https://threejs.org/docs/index.html#api/en/objects/Mesh) which is made up from
a [`THREE.BoxGeometry`](https://threejs.org/docs/index.html#api/en/geometries/BoxGeometry) and
a [`THREE.MeshBasicMaterial`](https://threejs.org/docs/index.html#api/en/materials/MeshBasicMaterial).

We should now be looking at a white cube on a transparent background.

```svelte title="Scene.svelte" {1-8}+
<script>
  import { T } from '@threlte/core'
</script>

<T.Mesh>
  <T.BoxGeometry />
  <T.MeshBasicMaterial />
</T.Mesh>
```

<Example
  path="first-scene/step-1"
  hideCode
/>

<Tip type="info">
  #### attach

Behind the scenes we're using the property `attach` available on `<T>` to **attach an object to a property of
its parent**. Binding geometries to the property `geometry` and materials to the property `material` is a common
pattern so Threlte takes care of it for you.

  <details>
	<summary>
      Learn more
    </summary>

    We're using the property `attach` available on `<T>` to
    **attach an object to a property of its parent**. In our case we're **attaching** the underlying Three.js
    object of `<T.BoxGeometry>` to the property `geometry` of the `<T.Mesh>` component. We're also attaching
    the underlying Three.js object of `<T.MeshBasicMaterial>` to the property `material` of the `<T.Mesh>` component.

    ```svelte title="Scene.svelte"
    <script>
      import { T } from '@threlte/core'
    </script>

    <T.Mesh>
      <T.BoxGeometry attach="geometry" />
      <T.MeshBasicMaterial attach="material" />
    </T.Mesh>
    ```

    Binding geometries to the property `geometry` and materials to the property `material` is a common
    pattern so Threlte will take care of it. It checks for the properties `isMaterial` and `isGeometry` on
    the underlying Three.js object and attaches it to the correct property.

  </details>
</Tip>

<details>
	<summary>
		Three.js equivalent
	</summary>
  ```ts
  // creating the objects
  const geometry = new THREE.BoxGeometry()
  const material = new THREE.MeshBasicMaterial()
  const mesh = new THREE.Mesh()

// "attaching" the objects
mesh.geometry = geometry
mesh.material = material

````
</details>

## Modifying Objects


That cube is still a bit boring. Let's add some color to it, and make it a bit bigger! We also want to move it up a little to highlight it. We can do this by passing props to the
`<T>` component.

```svelte title="Scene.svelte" {5-7}m
<script>
import { T } from '@threlte/core'
</script>

<T.Mesh position.y={1}>
<T.BoxGeometry args={[1, 2, 1]} />
<T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
````

<Example
  path="first-scene/step-2"
  hideCode
/>

Threlte automatically generates props for `<T>` based on the underlying Three.js object. This means you can easily guess most `<T>` props
based on the <a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">Three.js docs</a> for the class you are using.

<details>
  <summary>
    Three.js equivalent
  </summary>

```ts
const mesh = new THREE.Mesh()
const geometry = new THREE.BoxGeometry(1, 2, 1)
const material = new THREE.MeshBasicMaterial()
mesh.position.y = 1
material.color.set('hotpink')
```

</details>

The special **args** prop we use in `<T.BoxGeometry>` corresponds to the
object's constructor arguments. Props interpreted from the underlying Three.js
object are called **auto props**, like `color` in our `<T.MeshBasicMaterial>`.
Leveraging Threlte's **Pierced Props** you can directly assigned to attributes
of props like `position.y` in our `<T.Mesh>`.

<details>
	<summary>
		Learn more
	</summary>
	#### `args`

    In Three.js objects are classes that are instantiated. These classes can
    receive one-time constructor arguments (`new THREE.SphereGeometry(1, 32)`). In
    Threlte, constructor arguments are always passed as an array via the prop
    `args`. If `args` change later on, the object must naturally get reconstructed
    from scratch!

    #### Auto Props

    For all other props, Threlte tries to automatically interpret props passed to `<T>` component.

    **Step 1.** *Find Properties* - First, Threlte will try to find the **property
    on the underlying Three.js object** based on the **name of the prop**. In our
    example, [`color` is a property of
    `THREE.MeshBasicMaterial`](https://threejs.org/docs/index.html#api/en/materials/MeshBasicMaterial.color).

    **Step 2.** *Try `set` Methods* - Next, Threlte will look for a `set` method
    on that property and use it to set the new value. In our example it will call
    `material.color.set('hotpink')` to set the color of our material.

    **Step 3.** *Try setting the property directly* - If there's no `set` method,
    it will try to set the property directly. In our example, this equated to
    `mesh.position.y = 1`.

    **Step 4.** *Check for array values* - When setting a property that accepts
    more than one value (such as a `THREE.Vector3`: `vec3.set(1, 2, 3)`), we can
    pass an array as a prop.

    **Step 5.** *Keep the prop type constant for the lifetime of the component* -
    If the prop value changes, Threlte will try to set the property again. If the
    type of the prop value changes, Threlte won't be able to reliably do that. For
    instance the type of the value of a variable that is used as a prop should not
    change from a single number to an array of numbers.

    #### Pierced Props

    Because the property `position` of our `THREE.Mesh` is a `THREE.Vector3`, it
    also has `x`, `y` and `z` properties which we can set directly via
    dot-notation, we call this **Pierced Props**.

</details>

<Tip
  type="tip"
  title="Primitive Values"
>
  From a performance perspective, it's often better to use pierced props because
  [primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) prop values can safely be
  compared for equality. This means that if the value of a prop doesn't change, Threlte will skip
  any updates to the underlying Three.js object.
</Tip>

<Tip
  type="warning"
  title="Constant prop types"
>
  The type of an inferred prop (or "auto prop") must be constant. This means that the type of a prop
  must not change for the lifetime of the component. For instance you can't use a variable as a prop
  that is an array of numbers and then later on change the value of that variable to a single
  number. This is considered a type change and therefore not allowed.
</Tip>

## Pointing the Camera

We're still staring at the side of a cube, let's add a camera and offset it from the center:

```svelte title="Scene.svelte" {5-11}+
<script>
  import { T } from '@threlte/core'
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh position.y={1}>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-3"
  hideCode
/>

We're again using the `<T>` component to create a [`THREE.PerspectiveCamera`](https://threejs.org/docs/index.html#api/en/cameras/PerspectiveCamera).
We're also passing a `makeDefault` prop which will make this camera the default camera of our application.
The renderer now uses this camera to render our scene.

<Tip type="info">
  #### Events

Threlte supports listening to certain <a href="/docs/reference/core/t#events">events on `<T/>` components</a>. Here, we use the `create`
event to get a reference to the underlying Three.js object as soon as it's created and use the method `lookAt` to look at the cube.

</Tip>

## Enabling Interactivity

Let's say we want to scale our cube as soon as we hover over it. We first have to import the
[plugin](/docs/learn/advanced/plugins) [`interactivity`](/docs/reference/extras/interactivity) from
[`@threlte/extras`](/docs/reference/extras/getting-started) and invoke it in our `Scene.svelte` file.

The `interactivity` allows us to add interaction event listeners to our `<T>` components. We will add `pointerenter` and
`pointerleave` event listeners to our cube. In the event handlers we'll update the value of a `Spring` from `svelte/motion`
and use its `.current` value to set the `scale` property of the `<T.Mesh>` component.

```svelte title="Scene.svelte" {3-4,6-7,20-22}+
<script>
  import { T } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-4"
  hideCode
/>

<Tip type="info" title="Automatic Vector & Scalar Detection">
  You might have noticed that we're only passing a single number to the prop `scale` on `<T.Mesh>`. Threlte automatically
  figures out whether you are passing an array or a number and uses the appropriate underlying Three.js method.

  <details>
    <summary>
      Learn more
    </summary>
    The component `<T>` will first look for a property `setScalar` on	the underlying Three.js object and use that method if
    only a single number is passed. This is equivalent to calling `scale.setScalar($scale)`.
  </details>
</Tip>

<Tip
  type="tip"
  title="Realtime Variables"
>
  When working with realtime apps where variables e.g. position and rotation change constantly, an
  easy way observe the values is with [live
  expressions](https://developer.chrome.com/docs/devtools/console/live-expressions/).
</Tip>

## Adding Animation

Let's add some motion to our cube. We will use Threlte's [`useTask`](/docs/reference/core/use-task) hook to tap
into Threlte's **unified frame loop** and run a function on every frame. We again use a Pierced Prop to let the
cube rotate around its y-axis.

```svelte title="Scene.svelte" {2}m {9-12,24}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshBasicMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-5"
  hideCode
/>

`useTask` registers a callback that will be invoked on every frame. The callback receives the time delta since the last frame as an argument. We use
the delta to update the rotation
[independent of the frame rate](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
– the cube will rotate at the same speed regardless of the frame rate.

## Adjusting the Lighting

We're almost done. Let's add some shading to our cube and a light source. We'll use a
`THREE.MeshStandardMaterial` on our cube and a `THREE.DirectionalLight` to illuminate our scene.

```svelte title="Scene.svelte" {32}m {22}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.DirectionalLight position={[0, 10, 10]} />

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshStandardMaterial color="hotpink" />
</T.Mesh>
```

<Example
  path="first-scene/step-6"
  hideCode
/>

## Casting Shadows

We would like our cube to cast a shadow. To do so, we need a floor for it to cast a shadow _on_,
so we add a new `<T.Mesh>` but this time with `<T.CircleGeometry>`. To enable shadows, we need to
set `castShadow` on both the light and our cube, and set `receiveShadow` on our new floor:

```svelte title="Scene.svelte" {22}m {24,33,39-45}+
<script>
  import { T, useTask } from '@threlte/core'
  import { interactivity } from '@threlte/extras'
  import { Spring } from 'svelte/motion'

  interactivity()

  const scale = new Spring(1)

  let rotation = 0
  useTask((delta) => {
    rotation += delta
  })
</script>

<T.PerspectiveCamera
  makeDefault
  position={[10, 10, 10]}
  oncreate={(ref) => {
    ref.lookAt(0, 1, 0)
  }}
/>

<T.DirectionalLight
  position={[0, 10, 10]}
  castShadow
/>

<T.Mesh
  rotation.y={rotation}
  position.y={1}
  scale={scale.current}
  onpointerenter={() => {
    scale.target = 1.5
  }}
  onpointerleave={() => {
    scale.target = 1
  }}
  castShadow
>
  <T.BoxGeometry args={[1, 2, 1]} />
  <T.MeshStandardMaterial color="hotpink" />
</T.Mesh>

<T.Mesh
  rotation.x={-Math.PI / 2}
  receiveShadow
>
  <T.CircleGeometry args={[4, 40]} />
  <T.MeshStandardMaterial color="white" />
</T.Mesh>
```

<Example
  path="first-scene/step-7"
  hideCode
/>

## Conclusion

Congratulations, you've just created your first Three.js scene with Threlte! It includes important
Three.js and Threlte concepts and should give you a good starting point for your first Threlte project.


================================================
File: apps/docs/src/content/learn/more/resources.mdx
================================================
---
category: More
title: Resources
---

The three.js space is constantly evolving and expanding. Whether you are a beginner
looking to get started or an experienced developer seeking advanced knowledge,
there are resources in the wider community which offer a wealth of information
and technologies to help.

## Underlying Libraries

The following libraries are foundational to understanding Threlte's architecture, functionalities and packages:

### [Three.js](https://threejs.org/)

An excellent starting point for 3D graphics on the web. Three.js serves as the backbone for rendering and creating 3D scenes in Threlte.

### [Rapier](https://www.rapier.rs/)

An essential library for real-time physics simulations. Rapier helps bring your Threlte projects to life with dynamic interactions.

### [Theatre.js](https://www.theatrejs.com/)

Focuses on timeline-based animations and offers intricate control over complex animations, making it easier to manage complex state changes in Threlte.

## General

### [Threejs Resources](https://threejsresources.com/)

A hub for all things 3D. From tools to textures, lighting & more.

## Shaders

GLSL (Graphics Library Shader Language) is a critical part of shader programming, which is central to achieving high-quality visual effects in Threlte.

### [The Book of Shaders](https://thebookofshaders.com/)

This resource breaks down complex shader programming into bite-sized lessons. A great starting point for anyone new to shaders.

### [Learn OpenGL](https://learnopengl.com/)

An in-depth resource for learning OpenGL and GLSL, covering topics from beginner to advanced levels. Learn OpenGL offers tutorials that are easily applicable to Threlte's context.

We hope you find these resources valuable in your journey to mastering Threlte. Happy Learning!


